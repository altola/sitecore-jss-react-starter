{"version":3,"sources":["assets/jss-logo.png","components/ContentBlock/index.js","temp/componentFactory.js","lib/SitecoreContextFactory.js","temp/config.js","Layout.js","NotFound.js","RouteHandler.js","AppRoot.js","index.js","i18n.js"],"names":["module","exports","__webpack_require__","p","components_ContentBlock","_ref","fields","react_default","a","createElement","Fragment","dist","tag","className","field","heading","content","components","Map","componentFactory","componentName","get","set","SitecoreContextFactory","config","sitecoreApiKey","sitecoreApiHost","jssAppName","defaultLanguage","Layout_Navigation","t","i18n","NavLink","to","src","jss_logo_default","height","alt","href","target","rel","Object","dist_es","src_Layout","_ref2","route","Helmet_default","pageTitle","value","name","rendering","src_NotFound","props","ssrInitialState","RouteHandler_RouteHandler","RouteHandler","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","call","state","notFound","routeData","sitecore","setSitecoreContext","_objectSpread","itemId","context","language","window","componentIsMounted","languageIsChanging","updateLanguage","updateRouteData","_this2","sitecoreRoutePath","match","params","sitecoreRoute","startsWith","options","arguments","length","undefined","fetchOptions","layoutServiceConfig","host","querystringParams","sc_lang","sc_apikey","requestConfig","fetchRouteData","catch","error","console","getRouteData","lang","then","setState","_this3","newLanguage","es","changeLanguage","forceUpdate","previousProps","existingRoute","url","newRoute","location","assign","_this$state","Component","routePatterns","src_AppRoot","path","Router","routeRenderFunction","contextFactory","Switch","map","routePattern","Route","key","render","ssrState","dictionary","renderFunction","react_dom_default","__JSS_STATE__","hydrate","Promise","resolve","reject","debug","lng","fallbackLng","load","useCookie","interpolation","escapeValue","resources","translation","use","init","dictionaryServicePath","concat","backend","loadPath","parse","data","parsedData","JSON","phrases","lib_default","rootElement","document","getElementById","pathname","BrowserRouter"],"mappings":"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","file":"static/js/main.48543dc7.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/jss-logo.54f6759d.png\";","import React from \"react\";\r\nimport { Text, RichText } from \"@sitecore-jss/sitecore-jss-react\";\r\n\r\nconst ContentBlock = ({ fields }) => (\r\n  <React.Fragment>\r\n    <Text tag=\"h2\" className=\"display-4\" field={fields.heading} />\r\n    <RichText className=\"contentDescription\" field={fields.content} />\r\n  </React.Fragment>\r\n);\r\n\r\nexport default ContentBlock;\r\n","/* eslint-disable */\n// Do not edit this file, it is auto-generated at build time!\n// See scripts/generate-component-factory.js to modify the generation of this file.\nimport ContentBlock from '../components/ContentBlock';\n\nconst components = new Map();\ncomponents.set('ContentBlock', ContentBlock);\n\nexport default function componentFactory(componentName) {\n  return components.get(componentName);\n};\n","import { SitecoreContextFactory } from '@sitecore-jss/sitecore-jss-react';\n\n/*\n  The SitecoreContextFactory stores the current Sitecore context for the app.\n  For example, whether the page is currently being edited, or the current language.\n  Note that the export makes this essentially a singleton, so we can store state in it.\n\n  The Sitecore context is generally updated on route change (/src/index.js).\n  The `withSitecoreContext()` higher order component from `sitecore-jss-react`\n  can be used to access the context from within a component.\n*/\nexport default new SitecoreContextFactory();\n","/* eslint-disable */\n// Do not edit this file, it is auto-generated at build time!\n// See scripts/bootstrap.js to modify the generation of this file.\nexport default {\n  \"sitecoreApiKey\": \"{0CC34818-7B11-4519-9125-3597BDA3A00E}\",\n  \"sitecoreApiHost\": \"http://symdev\",\n  \"jssAppName\": \"sym\",\n  \"defaultLanguage\": \"en\"\n};","import React from 'react';\r\nimport { Placeholder } from '@sitecore-jss/sitecore-jss-react';\r\nimport { NavLink } from 'react-router-dom';\r\nimport { translate } from 'react-i18next';\r\nimport Helmet from 'react-helmet';\r\n\r\n// Using bootstrap is completely optional. It's used here to provide a clean layout for samples,\r\n// without needing extra CSS in the sample app. Remove it in package.json as well if it's removed here.\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\nimport './assets/app.css';\r\nimport logo from './assets/jss-logo.png';\r\n\r\n/*\r\n  APP LAYOUT\r\n  This is where the app's HTML structure and root placeholders should be defined.\r\n\r\n  All routes share this root layout by default (this could be customized in RouteHandler),\r\n  but components added to inner placeholders are route-specific.\r\n*/\r\n\r\nlet Navigation = ({ t, i18n }) => (\r\n  <div className=\"nav d-flex flex-column flex-md-row align-items-center p-3 px-md-4 mb-3 border-bottom\">\r\n    <h5 className=\"my-0 mr-md-auto font-weight-normal\">\r\n      <NavLink to=\"/\">\r\n        <img src={logo} height={50} alt=\"Sitecore\" />\r\n      </NavLink>\r\n    </h5>\r\n    <nav className=\"my-2 my-md-0 mr-md-3\">\r\n      <a\r\n        className=\"p-2\"\r\n        href=\"https://jss.sitecore.net\"\r\n        target=\"_blank\"\r\n        rel=\"noopener noreferrer\"\r\n      >\r\n        {t('Documentation')}\r\n      </a>\r\n    </nav>\r\n  </div>\r\n);\r\n\r\n// inject dictionary props (`t`) into navigation so we can translate it\r\n// NOTE: using this is needed instead of using i18next directly to keep\r\n// the component state updated when i18n state (e.g. current language) changes\r\nNavigation = translate()(Navigation);\r\n\r\nconst Layout = ({ route }) => (\r\n  <React.Fragment>\r\n    {/* react-helmet enables setting <head> contents, like title and OG meta tags */}\r\n    <Helmet>\r\n      <title>\r\n        {(route.fields && route.fields.pageTitle && route.fields.pageTitle.value) || 'Page'}\r\n      </title>\r\n    </Helmet>\r\n\r\n    <Navigation />\r\n\r\n    {/* root placeholder for the app, which we add components to using route data */}\r\n    <div className=\"container\">\r\n      <Placeholder name=\"jss-main\" rendering={route} />\r\n    </div>\r\n  </React.Fragment>\r\n);\r\n\r\nexport default Layout;\r\n","import React from 'react';\n\n// Renders a route-not-found message when no route is available from Sitecore\n// The JSS equivalent of a 404 Not Found page.\n\n// This is invoked from RouteHandler when Sitecore returns no valid route data.\n\nconst NotFound = (props) => <h1>Page not found</h1>;\n\nexport default NotFound;\n","import React from 'react';\nimport i18n from 'i18next';\nimport Helmet from 'react-helmet';\nimport { isExperienceEditorActive, dataApi } from '@sitecore-jss/sitecore-jss-react';\nimport SitecoreContextFactory from './lib/SitecoreContextFactory';\nimport config from './temp/config';\nimport Layout from './Layout';\nimport NotFound from './NotFound';\n\n// Dynamic route handler for Sitecore items.\n// Because JSS app routes are defined in Sitecore, traditional static React routing isn't enough -\n// we need to be able to load dynamic route data from Sitecore after the client side route changes.\n// So react-router delegates all route rendering to this handler, which attempts to get the right\n// route data from Sitecore - and if none exists, renders the not found component.\n\nlet ssrInitialState = null;\n\nexport default class RouteHandler extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      notFound: true,\n      routeData: ssrInitialState, // null when client-side rendering\n      defaultLanguage: config.defaultLanguage,\n    };\n\n    if (ssrInitialState && ssrInitialState.sitecore && ssrInitialState.sitecore.route) {\n      // set the initial sitecore context data if we got SSR initial state\n      SitecoreContextFactory.setSitecoreContext({\n        route: ssrInitialState.sitecore.route,\n        itemId: ssrInitialState.sitecore.route.itemId,\n        ...ssrInitialState.sitecore.context,\n      });\n    }\n\n    // route data from react-router - if route was resolved, it's not a 404\n    if (props.route !== null) {\n      this.state.notFound = false;\n    }\n\n    // if we have an initial SSR state, and that state doesn't have a valid route data,\n    // then this is a 404 route.\n    if (ssrInitialState && (!ssrInitialState.sitecore || !ssrInitialState.sitecore.route)) {\n      this.state.notFound = true;\n    }\n\n    // if we have an SSR state, and that state has language data, set the current language\n    // (this makes the language of content follow the Sitecore context language cookie)\n    // note that a route-based language (i.e. /de-DE) will override this default; this is for home.\n    if (ssrInitialState && ssrInitialState.context && ssrInitialState.context.language) {\n      this.state.defaultLanguage = ssrInitialState.context.language;\n    }\n\n    // once we initialize the route handler, we've \"used up\" the SSR data,\n    // if it existed, so we want to clear it now that it's in react state.\n    // future route changes that might destroy/remount this component should ignore any SSR data.\n    // EXCEPTION: Unless we are still SSR-ing. Because SSR can re-render the component twice\n    // We test for SSR by checking for Node-specific process.env variable.\n    if (typeof window !== 'undefined') {\n      ssrInitialState = null;\n    }\n\n    this.componentIsMounted = false;\n    this.languageIsChanging = false;\n\n    // tell i18next to sync its current language with the route language\n    this.updateLanguage();\n  }\n\n  componentDidMount() {\n    // if no existing routeData is present (from SSR), get Layout Service fetching the route data\n    if (!this.state.routeData) {\n      this.updateRouteData();\n    }\n\n    this.componentIsMounted = true;\n  }\n\n  componentWillUnmount() {\n    this.componentIsMounted = false;\n  }\n\n  /**\n   * Loads route data from Sitecore Layout Service into state.routeData\n   */\n  updateRouteData() {\n    let sitecoreRoutePath = this.props.route.match.params.sitecoreRoute || '/';\n    if (!sitecoreRoutePath.startsWith('/')) {\n      sitecoreRoutePath = `/${sitecoreRoutePath}`;\n    }\n\n    const language = this.props.route.match.params.lang || this.state.defaultLanguage;\n\n    // get the route data for the new route\n    getRouteData(sitecoreRoutePath, language).then((routeData) => {\n      if (routeData !== null) {\n        // set the sitecore context data and push the new route\n        SitecoreContextFactory.setSitecoreContext({\n          route: routeData.sitecore.route,\n          itemId: routeData.sitecore.route.itemId,\n          ...routeData.sitecore.context,\n        });\n        this.setState({ routeData, notFound: false });\n      } else {\n        this.setState({ notFound: true });\n      }\n    });\n  }\n\n  /**\n   * Updates the current app language to match the route data.\n   */\n  updateLanguage() {\n    const newLanguage = this.props.route.match.params.lang || this.state.defaultLanguage;\n\n    if (i18n.language !== newLanguage) {\n      this.languageIsChanging = true;\n\n      i18n.changeLanguage(newLanguage, () => {\n        this.languageIsChanging = false;\n\n        // if the component is not mounted, we don't care\n        // (next time it mounts, it will render with the right language context)\n        if (this.componentIsMounted) {\n          // after we change the i18n language, we need to force-update React,\n          // since otherwise React won't know that the dictionary has changed\n          // because it is stored in i18next state not React state\n          this.forceUpdate();\n        }\n      });\n    }\n  }\n\n  componentDidUpdate(previousProps) {\n    const existingRoute = previousProps.route.match.url;\n    const newRoute = this.props.route.match.url;\n\n    // don't change state (refetch route data) if the route has not changed\n    if (existingRoute === newRoute) {\n      return;\n    }\n\n    // if in experience editor - force reload instead of route data update\n    // avoids confusing Sitecore's editing JS\n    if (isExperienceEditorActive()) {\n      window.location.assign(newRoute);\n      return;\n    }\n\n    this.updateLanguage();\n    this.updateRouteData();\n  }\n\n  render() {\n    const { notFound, routeData } = this.state;\n\n    // no route data for the current route in Sitecore - show not found component.\n    // Note: this is client-side only 404 handling. Server-side 404 handling is the responsibility\n    // of the server being used (i.e. node-express-ssr and Sitecore intergrated rendering know how to send 404 status codes).\n    if (notFound) {\n      return (\n        <div>\n          <Helmet>\n            <title>{i18n.t('Page not found')}</title>\n          </Helmet>\n          <NotFound />\n        </div>\n      );\n    }\n\n    // Don't render anything if the route data or dictionary data is not fully loaded yet.\n    // This is a good place for a \"Loading\" component, if one is needed.\n    if (!routeData || this.languageIsChanging) {\n      return null;\n    }\n\n    // Render the app's root structural layout\n    return <Layout route={routeData.sitecore.route} />;\n  }\n}\n\n/**\n * Sets the initial state provided by server-side rendering.\n * Setting this state will bypass initial route data fetch calls.\n * @param {object} ssrState\n */\nexport function setServerSideRenderingState(ssrState) {\n  ssrInitialState = ssrState;\n}\n\n/**\n * Gets route data from Sitecore. This data is used to construct the component layout for a JSS route.\n * @param {string} route Route path to get data for (e.g. /about)\n * @param {string} language Language to get route data in (content language, e.g. 'en')\n * @param {dataApi.LayoutServiceRequestOptions} options Layout service fetch options\n */\nfunction getRouteData(route, language, options = {}) {\n  const fetchOptions = {\n    layoutServiceConfig: { host: config.sitecoreApiHost },\n    querystringParams: { sc_lang: language, sc_apikey: config.sitecoreApiKey },\n    requestConfig: options,\n  };\n\n  return dataApi.fetchRouteData(route, fetchOptions).catch((error) => {\n    console.error('Route data fetch error', error);\n    return null;\n  });\n}\n","import React from \"react\";\nimport { SitecoreContext } from \"@sitecore-jss/sitecore-jss-react\";\nimport { Route, Switch } from \"react-router-dom\";\nimport componentFactory from \"./temp/componentFactory\";\nimport SitecoreContextFactory from \"./lib/SitecoreContextFactory\";\nimport RouteHandler from \"./RouteHandler\";\n\n// This is the main JSX entry point of the app invoked by the renderer (server or client rendering).\n// By default the app's normal rendering is delegated to <RouteHandler> that handles the loading of JSS route data.\n\n// support languages in the URL prefix\n// e.g. /da-DK/path, or /en/path, or /path\nexport const routePatterns = [\n  \"/:lang([a-z]{2}-[A-Z]{2})/:sitecoreRoute*\",\n  \"/:lang([a-z]{2})/:sitecoreRoute*\",\n  \"/:sitecoreRoute*\"\n];\n\n// wrap the app with:\n// SitecoreContext: provides component resolution and context services via withSitecoreContext\n// Router: provides a basic routing setup that will resolve Sitecore item routes and allow for language URL prefixes.\nconst AppRoot = ({ path, Router }) => {\n  const routeRenderFunction = props => <RouteHandler route={props} />;\n  return (\n    <SitecoreContext\n      componentFactory={componentFactory}\n      contextFactory={SitecoreContextFactory}\n    >\n      <Router location={path} context={{}}>\n        <Switch>\n          {routePatterns.map(routePattern => (\n            <Route\n              key={routePattern}\n              path={routePattern}\n              render={routeRenderFunction}\n            />\n          ))}\n        </Switch>\n      </Router>\n    </SitecoreContext>\n  );\n};\n\nexport default AppRoot;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from 'react-router-dom';\nimport AppRoot from './AppRoot';\nimport { setServerSideRenderingState } from './RouteHandler';\nimport i18ninit from './i18n';\n\n/* eslint-disable no-underscore-dangle */\n\nlet renderFunction = ReactDOM.render;\n\n/*\n  SSR Data\n  If we're running in a server-side rendering scenario,\n  the server will provide the window.__JSS_STATE__ object\n  for us to acquire the initial state to run with on the client.\n\n  This enables us to skip a network request to load up the layout data.\n\n  SSR is initiated from /server/server.js.\n*/\nif (window.__JSS_STATE__) {\n  // push the initial SSR state into the route handler, where it will be used\n  setServerSideRenderingState(window.__JSS_STATE__);\n\n  // when React initializes from a SSR-based initial state, you need to render with `hydrate` instead of `render`\n  renderFunction = ReactDOM.hydrate;\n}\n\n/*\n  App Rendering\n*/\n// initialize the dictionary, then render the app\n// note: if not making a multlingual app, the dictionary init can be removed.\ni18ninit().then(() => {\n  // HTML element to place the app into\n  const rootElement = document.getElementById('root');\n\n  renderFunction(\n    <AppRoot\n      path={window.location.pathname}\n      Router={BrowserRouter}\n    />,\n    rootElement\n  );\n});\n","import i18n from 'i18next';\nimport fetchBackend from 'i18next-fetch-backend';\nimport { reactI18nextModule } from 'react-i18next';\nimport config from './temp/config';\n\n/**\n * Initializes the i18next library to provide a translation dictionary to the app.\n * If your app is not multilingual, this file and references to it can be removed.\n * Elsewhere in the app to use the dictionary `import { t } from 'i18next'; ... t('key')`\n * @param {string} language Optional, the initial language. Only used for SSR; otherwise language set in RouteHandler.\n * @param {*} dictionary Optional, the dictionary to load. Only used for SSR; otherwise, the dictionary is loaded via JSS dictionary service.\n */\nexport default function i18nInit(language, dictionary) {\n  return new Promise((resolve, reject) => {\n    const options = {\n      debug: false,\n      lng: language,\n      fallbackLng: false, // fallback to keys\n      load: 'currentOnly', // e.g. don't load 'es' when requesting 'es-MX' -- Sitecore config should handle this\n      useCookie: false, // using URLs and Sitecore to store language context, don't need a cookie\n\n      interpolation: {\n        escapeValue: false, // not needed for react\n      },\n    };\n\n    if (dictionary) {\n      // if we got dictionary passed, that means we're in a SSR context with a server-provided dictionary\n      // so we do not want a backend, because we already know all possible keys\n      options.resources = {};\n      options.resources[language] = {\n        translation: dictionary,\n      };\n\n      i18n.use(reactI18nextModule).init(options, (error) => {\n        if (error) reject(error);\n        resolve();\n      });\n    } else {\n      // We're running client-side, so we get translation data from the Sitecore dictionary API using fetch backend\n      // For higher performance (but less simplicity), consider adding the i18n chained backend to a local cache option like the local storage backend.\n\n      // eslint-disable-next-line prettier/prettier\n      const dictionaryServicePath = `${config.sitecoreApiHost}/sitecore/api/jss/dictionary/${config.jssAppName}/{{lng}}?sc_apikey=${config.sitecoreApiKey}`;\n\n      options.backend = {\n        loadPath: dictionaryServicePath,\n        parse: (data) => {\n          const parsedData = JSON.parse(data);\n          if (parsedData.phrases) {\n            return parsedData.phrases;\n          }\n          return parsedData;\n        },\n      };\n\n      i18n\n        .use(fetchBackend)\n        .use(reactI18nextModule)\n        .init(options, (error) => {\n          if (error) reject(error);\n\n          resolve();\n        });\n    }\n  });\n}\n"],"sourceRoot":""}